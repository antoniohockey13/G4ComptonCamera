**Information we have:**
- Cone:  x = lambda*R(phi, u)*R(theta,u*(0, 1, 0))*u + v
	- u --> hit-vertex
	- v --> vertex
	- theta --> Compton angle
	- phi --> Parameter
	- lambda --> Parameter

- voxel: define by 9 planes:
	- x >
	- x <
	- y >
	- y <
	- z >
	- z <

--------------------------------------------------------------

**Pseudocode**

def select_voxel(cones,  voxels):
	intersection = np.zeros(len(voxels)) # Array with number of cones intersecting voxel 0 in position 0 ...
	for icone in cones:
		for ivoxel in voxels:
			if (check_if_cone_in_voxel(icone, ivoxel)):
				intersection[ivoxel] += 1

	voxel_selected = []
	for i in intersection:
		if intersection[i]> %*len(cones):
			voxel_selected.append[ivoxel]
	return voxel_selected 

space_limits = {
		"x>" :
		"x<" :
		"y>" :
		"y<" :
		"z>" :
		"z<" :
		}

def voxelise_space(space_limits, voxel_number_side):
	"""
	space limits are assumed to be cubic and voxelisation will be done into cubic voxels
	"""
	len_x = (space_limits["x<"] - space_limits["x>"])/voxel_number_side
	len_y = (space_limits["y<"] - space_limits["y>"])/voxel_number_side
	len_z = (space_limits["z<"] - space_limits["z>"])/voxel_number_side
	
	voxels = {
		"Number" : []
		"x>" : []
                "x<" : []
                "y>" : []
                "y<" : []
                "z>" : []
                "z<" : []
		}
	numb = 0
	for ix in range(voxel_number_side):
		for iy in range(voxel_number_side):
			for iz in range(voxel_number_side):
				# Append voxel
				voxels["Number].append(numb)
				voxels["x>"].append(space_limits["x>"] + len_x*ix)
				voxels["x<"].append(space_limits["x>"] + len_x*(ix+1))
				voxels["y>"].append(space_limits["y>"] + len_y*iy)
				voxels["y<"].append(space_limits["y>"] + len_y*(iy+1))
				voxels["z>"].append(space_limits["z>"] + len_z*iz)
				voxels["z<"].append(space_limits["z>"] + len_z*(iz+1))
				# Add 1 to number
				numb +=1
	return voxels 

def check_if_cone_in_voxel(cone, voxel):
	# Find intersection points between voxels limits and cone
	for ix in voxel["x>"]:
		for iy in voxel["y>"]:
			solve(cono, x = [ix, iy]) # obtain phi and lambda
			z = # compute z
			if z> voxel["z>"] and z<["z<"]:
				return True
			else: 
				return False


def cono (lambda, phi):
	"""
	theta, u and v are known.
	theta = compton angle
	u = hit-vertex
	v = vertex
	x = pto
	"""
	return lambda*rotate(phi)*rotate(theta)*u+v-x	
-----------------------------------------------------------------------
I studied one case and once you multiply both rotation matrix without knowing phi it is obtained that 

 x              n1 cos(phi) + n2 sin(phi) + n3
[y] = lambda *[ n4 cos(phi) + n5 sin(phi) + n6 ]+ v
 z              n7 cos(phi) + n8 sin(phi) + n9

So if we could compute those n1-n9 in a general way then it should be possible to solve x and y lines obtaining phi and lambda and then just insert that into z so a z value is obtained. This way we can check what voxel the cone surface is.


That matrix is obtained performing 2 rotation, first one the compton angle R(theta) and then the phi rotation R(phi)


R(theta) can be performed with the function rotate already implemented in python. 


Then it is just needed to obtain the numbers with sins and cosines to multiply them with that matrix
Done with sympy.
